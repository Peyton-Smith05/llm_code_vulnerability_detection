import os
import glob
import zipfile
import re
import subprocess
import random
import csv
import fnmatch

def recursive_glob(rootdir='.', pattern='*'):
    matches = []
    for root, dirnames, filenames in os.walk(rootdir):
        for filename in fnmatch.filter(filenames, pattern):
            matches.append(os.path.join(root, filename))
    return matches

def extract_code_blocks(diff_file, original_file, modified_file, error_lines, context_lines_hi=random.randint(3,12), context_lines_lo=random.randint(3,12)):
    # Define a class to store code block information
    class CodeBlock:
        def __init__(self, error_line, fix_line, bad_code, good_code, lo, hi):
            self.error_line = error_line
            self.fix_line = fix_line
            self.bad_code = bad_code
            self.good_code = good_code
            self.lo = lo
            self.hi = hi

    # Read the diff file
    with open(diff_file, 'r') as file:
        diff_content = file.readlines()

    # Read the original and modified files
    with open(original_file, 'r') as file:
        original_content = file.readlines()

    with open(modified_file, 'r') as file:
        modified_content = file.readlines()

    # Regular expression to find the line number and type of change
    line_regex = re.compile(r'(\d+)(,\d+)?([acd])(\d+)(,\d+)?')

    # Mapping of line numbers in modified file to original file
    line_mapping = {}
    original_line = modified_line = 0

    for line in diff_content:
        match = line_regex.match(line)
        if match:
            start_line_orig, _, _, start_line_mod, _ = match.groups()
            original_line = int(start_line_orig)
            modified_line = int(start_line_mod)

        elif line.startswith('< '):
            line_mapping[modified_line] = original_line
            original_line += 1

        elif line.startswith('> '):
            modified_line += 1

        else:
            original_line += 1
            modified_line += 1

    # List to hold the code block information
    code_blocks = []

    # Extract the blocks of code
    for error_line in error_lines:
        start = max(1, int(error_line) - context_lines_lo)
        end = min(len(modified_content), int(error_line) + context_lines_hi)
        bad_code = ''.join(modified_content[start-1:end])

        if error_line in line_mapping:
            orig_line = line_mapping[error_line]
            start = max(1, orig_line - context_lines_lo)
            end = min(len(original_content), orig_line + context_lines_hi)
            good_code = ''.join(original_content[start-1:end])
            code_blocks.append(CodeBlock(error_line, orig_line, bad_code, good_code, context_lines_lo, context_lines_hi))

    return code_blocks


def get_bug_information_from_inject_log(inject_log):
    extracted_data = []
    with open(log, 'r') as inject_log:
            inject_log_content = inject_log.read()
            pattern = r"SELECTED\s+BUG\s+(?P<bug_number>\d+)\s+id=(?P<bug_id>\d+).*?ATP file:\s+(?P<atp_file>[^\s]+)\s+line:\s+(?P<line>\d+)\s+DUA:.*?Src_file:\s+(?P<src_file>[^\s]+).*?Filename:\s+(?P<filename>[^\s]+)"

            # Find all matches with the new pattern
            matches_with_bug_info = re.findall(pattern, inject_log_content, re.DOTALL)

            # Process and store the information including bug number and id
            
            for match in matches_with_bug_info:
                bug_number, bug_id, atp_file, line, src_file, filename = match
                extracted_data.append({
                    'Bug Number': bug_number,
                    'Bug ID': bug_id,
                    'ATP File': atp_file,
                    'Line': line,
                    'DUA Source File': src_file,
                    'Filename': filename,
                    'Input File Path': 0,
                    'Test Command': 0,
                    'Bug Type': 0,
                    'Bad Code': '',
                    'Good Code':'',
                    'Line Start':0,
                    'Line End':0
                })
                
            id_list_pattern = r"A BOUNTIFUL CROP OF BUGS: ([\d,]+)"
            id_list_match = re.search(id_list_pattern, inject_log_content)
            extracted_id_list = []
            
            if id_list_match:
                extracted_id_list = id_list_match.group(1).split(',')
                extracted_data = [data for data in extracted_data if data['Bug ID'] in extracted_id_list]
                
                
#                print(inject_log_content)
                bug_validation_pattern = r"Validating bug (\d+) of 50\s+.*?fuzzed = \[(.*?)\]\s+Run modified program: (.*?)\s+.*?bug type is (.*?)\s+"
                bug_validation_matches = re.findall(bug_validation_pattern, inject_log_content, re.DOTALL)

                # Process and store the information
                extracted_bug_info = []
                for match in bug_validation_matches:
                    bug_number, fuzzed_path, run_command, bug_type = match
                    index = next((i for i, bug in enumerate(extracted_data) if bug['Bug Number'] == str(int(bug_number)-1)), None)
                    if index != None:
                        extracted_data[index]['Input File Path'] = fuzzed_path
                        extracted_data[index]['Test Command'] = run_command
                        extracted_data[index]['Bug Type'] = bug_type
                    else:
                        continue
                    
                
            else:
                # Check if the orginal input failed. If so get that file path
                pass
       
    return extracted_data
    
    
    
current_directory = '/home/vagrant/'
pattern = './**/inject-*.log'
projects = ["pcre2", "blecho", "file", "toy", "jq"]
project_tars = ['pcre2-10.2', 'blecho', 'file-5.22', 'toy', 'jq-1.6']

data = []

for project in projects:
        
    os.chdir(current_directory + 'lava/target_injections/' + project + '/logs/')
    inject_logs = recursive_glob(current_directory + 'lava/target_injections/' + project + '/logs/', 'inject-*.log')
    
    print("INJECT LOGS:", len(inject_logs))
    for log in inject_logs:
        inject_log_data = get_bug_information_from_inject_log(log)
        
        print("INJECT LOG DATA:", len(inject_log_data))
        
        # Change the directory to bugs/0/project
        os.chdir(current_directory + "lava/target_injections/" + project + '/bugs/0/'+ project_tars[projects.index(project)])
            
        # Change the git branch to 'git checkout buildX'
        subprocess.call(['git', 'checkout', 'build'+str(inject_logs.index(log)+1)])
        
        # Change the directory to bugs/0/
        os.chdir(current_directory + "lava/target_injections/" + project + '/bugs/0/')
       
        for i, bug in enumerate(inject_log_data):
            
            diff_file = 'diff_output.txt' # Path to the diff output file
            
            original_file = './'+project_tars[projects.index(project)] + '_original/' + project_tars[projects.index(project)] + '/' +  bug['ATP File']
            modified_file = './'+project_tars[projects.index(project)] + '/' +  bug['ATP File'] 
            error_lines = [int(bug['Line'])] 
            
            # Get the diff file from command
            subprocess.call(['diff', original_file, modified_file], stdout=open('diff_output.txt', 'w')) 

            blocks = extract_code_blocks(diff_file, original_file, modified_file, error_lines)
            #print("BLOCKS:", blocks)
            if blocks:
                print(log)
                inject_log_data[i]['Good Code'] = blocks[0].good_code
                inject_log_data[i]['Bad Code'] = blocks[0].bad_code
                inject_log_data[i]['Line Start'] = blocks[0].error_line - blocks[0].lo
                inject_log_data[i]['Line End'] = blocks[0].error_line + blocks[0].hi
            
                data.append(inject_log_data[i])

os.chdir(current_directory + 'lava/')
# Open a CSV file for writing
with open('data.csv', 'wb') as file:
    writer = csv.DictWriter(file, fieldnames=['Text', 'Instruction', 'Input', 'Response'])
    writer.writeheader()

    for bug in data:
        # Format the data using str.format() method
        formatted_data = {
            'Text': "Below is an instruction that describes a task, paired with an input that provides further context.",
            'Instruction': "Evaluate the code for any vulnerabilities. If any, output the line number of the vulnerability and the complete rewritten code that corrects the vulnerability in JSON format.",
            'Input': "Line Start-{Line_Start}\nLine End-{Line_End}\n\n{Bad_Code}".format(
                Line_Start=bug['Line Start'], Line_End=bug['Line End'], Bad_Code=bug['Bad Code']),
            'Response': "{{\n\t\"vulnerabilities\": \n\t{{\n\t\t1 : \n\t\t{{\n\t\t\t\"Line\": {Line},\n\t\t\t\"Correction\": {Good_Code},\n\t\t}}\n\t}}\n}}".format(
                Line=bug['Line'], Good_Code=bug['Good Code'])
        }
        writer.writerow(formatted_data)

print("CSV file created successfully.")
            