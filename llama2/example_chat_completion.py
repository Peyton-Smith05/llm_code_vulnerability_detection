# Copyright (c) Meta Platforms, Inc. and affiliates.
# This software may be used and distributed according to the terms of the Llama 2 Community License Agreement.

from typing import List, Optional

import fire

import time

from llama import Llama, Dialog

import pandas as pd

import json

import random

import re



def main(
    ckpt_dir: str,
    tokenizer_path: str,
    temperature: float = 0.6,
    top_p: float = 0.9,
    max_seq_len: int = 512,
    max_batch_size: int = 8,
    max_gen_len: Optional[int] = None,
):
    """
    Entry point of the program for generating text using a pretrained model.

    Args:
        ckpt_dir (str): The directory containing checkpoint files for the pretrained model.
        tokenizer_path (str): The path to the tokenizer model used for text encoding/decoding.
        temperature (float, optional): The temperature value for controlling randomness in generation.
            Defaults to 0.6.
        top_p (float, optional): The top-p sampling parameter for controlling diversity in generation.
            Defaults to 0.9.
        max_seq_len (int, optional): The maximum sequence length for input prompts. Defaults to 512.
        max_batch_size (int, optional): The maximum batch size for generating sequences. Defaults to 8.
        max_gen_len (int, optional): The maximum length of generated sequences. If None, it will be
            set to the model's max sequence length. Defaults to None.
    """
    
    generator = Llama.build(
        ckpt_dir=ckpt_dir,
        tokenizer_path=tokenizer_path,
        max_seq_len=max_seq_len,
        max_batch_size=max_batch_size,
    )
    
    
    

    # Read the CSV file
    df_correction = pd.read_csv("data/input.csv")
    sampled_df = df_correction.sample(n=3000, random_state=56)
    
    # Extract the 'bad_function' column values into a list
    bad_function_list = sampled_df['bad_function'].tolist()
    bad_function_labels = sampled_df['cwe'].tolist()
    sampled_df = sampled_df.drop(columns=['bad_function', 'Patch'])
    
    sampled_df.to_csv("selected_input.csv", index=False)
    
    llama2_output = []
    real = []
    print(len(bad_function_list))
    for item in range(len(bad_function_list)):
        print("Item:", item)
        dialogs: List[Dialog] = [ ]
        new_dialog = [
            {
                    "role": "system",
                    "content": """
                    You are a code vulnerability analyzer. You receive code as input. For output you are only allowed to output the CWE number of the error you find and the line number associated with the error separated by a comma. Format your output to be CWE-###, line ###. DO NOT OUTPUT ANYTHING ELSE OTHER THAN THOSE TWO THINGS.
                    """,
                },
                {"role": "user", "content": bad_function_list[item] },
        ]
        
        dialogs.append(new_dialog)
        
        try:
            starttime = time.time()
            print("Starting chat completion")
            results = generator.chat_completion(
                dialogs,  # type: ignore
                max_gen_len=max_gen_len,
                temperature=temperature,
                top_p=top_p,
            )

            endtime = time.time()

            print("End chat completion. Duration:", endtime-starttime)
              
                
        except Exception as e:
            print("An error occurred: ", e)
            
        print("Start results extraction")
        real.append(bad_function_labels[item])
        for dialog, result in zip(dialogs, results):

            llama2_output.append(result['generation']['content'])   
      
    predicted_cwe_list = []
    predicted_label_list = []
    real_list = []   
    
    for i, output in enumerate(llama2_output):
        try:
            # Regular expression to extract CWE number and line number
            pattern = r"CWE-(\d+), line (\d+)"

            # Extracting the values using regex
            match = re.search(pattern, output)
            cwe_number, line_number = match.groups() if match else (None, None)
            cwe_number = 'CWE' + cwe_number
            predicted_cwe_list.append(cwe_number)
            predicted_label_list.append(line_number)
            real_list.append(real[i])
    
            
        except Exception as e:
            print("Failed", e)
            print(output)
            continue
    print("End results extraction")
    print("Writing to csv")
    df_results = pd.DataFrame({'cwe': predicted_cwe_list,'line': predicted_label_list, 'real':real_list})
    df_results.to_csv('output_results.csv', index=False)
    df_results['match'] = df_results['cwe'] == df_results['real']
    percentage_equal = (df_results['match'].sum() / len(df_results)) * 100
    df_results = df_results.drop('match', axis=1)

    # Print the percentage
    print(f"The accuracy of untrained llama2 is: {percentage_equal:.2f}%")


if __name__ == "__main__":
    fire.Fire(main)
